name: Deploy Echo MCP Client

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: echo-mcp-client
  IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests
      run: |
        python -m pytest src/tests/ -v --tb=short --cov=src --cov-report=xml

    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  build:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    outputs:
      image: ${{ steps.build.outputs.image }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
        provenance: false

    - name: Generate artifact attestation
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY}}
        subject-digest: ${{ steps.build.outputs.digest }}
        push-to-registry: true

  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download task definition
      run: |
        aws ecs describe-task-definition \
          --task-definition echo-mcp-client \
          --query 'taskDefinition' \
          --region ${{ env.AWS_REGION }} > taskdef.json || echo "Task definition not found, will create new one"

    - name: Update task definition
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        IMAGE_URI=${{ needs.build.outputs.image }}

        # Update the image URI in task definition
        if [ -f taskdef.json ]; then
          # Update existing task definition
          jq --arg IMAGE_URI "$IMAGE_URI" '.containerDefinitions[0].image = $IMAGE_URI' taskdef.json > taskdef-updated.json
          mv taskdef-updated.json taskdef.json
        else
          # Use the template taskdef.json
          sed -i "s|ACCOUNT_ID.dkr.ecr.REGION.amazonaws.com/echo-mcp-client:latest|$IMAGE_URI|g" taskdef.json
          sed -i "s/ACCOUNT_ID/$ACCOUNT_ID/g" taskdef.json
          sed -i "s/REGION/${{ env.AWS_REGION }}/g" taskdef.json
        fi

    - name: Register task definition
      id: register-task-def
      run: |
        TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://taskdef.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text \
          --region ${{ env.AWS_REGION }})
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_ENV
        echo "task-def-arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT

    - name: Check if service exists
      id: check-service
      run: |
        SERVICE_EXISTS=$(aws ecs describe-services \
          --cluster echo-mcp-client-cluster \
          --services echo-mcp-client-service \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0].status' \
          --output text 2>/dev/null || echo "MISSING")

        if [ "$SERVICE_EXISTS" = "ACTIVE" ]; then
          echo "service-exists=true" >> $GITHUB_OUTPUT
        else
          echo "service-exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Create ECS service (if not exists)
      if: steps.check-service.outputs.service-exists == 'false'
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

        # Get infrastructure outputs
        VPC_ID=$(aws cloudformation describe-stacks \
          --stack-name echo-mcp-client-infrastructure \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`VPCId`].OutputValue' \
          --output text)

        SUBNET_1=$(aws cloudformation describe-stacks \
          --stack-name echo-mcp-client-infrastructure \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet1Id`].OutputValue' \
          --output text)

        SUBNET_2=$(aws cloudformation describe-stacks \
          --stack-name echo-mcp-client-infrastructure \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`PublicSubnet2Id`].OutputValue' \
          --output text)

        SG_ID=$(aws cloudformation describe-stacks \
          --stack-name echo-mcp-client-infrastructure \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`ECSServiceSecurityGroupId`].OutputValue' \
          --output text)

        TG_ARN=$(aws cloudformation describe-stacks \
          --stack-name echo-mcp-client-infrastructure \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`ALBTargetGroupArn`].OutputValue' \
          --output text)

        aws ecs create-service \
          --cluster echo-mcp-client-cluster \
          --service-name echo-mcp-client-service \
          --task-definition ${{ env.TASK_DEF_ARN }} \
          --desired-count 1 \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_1,$SUBNET_2],securityGroups=[$SG_ID],assignPublicIp=ENABLED}" \
          --load-balancers "targetGroupArn=$TG_ARN,containerName=echo-mcp-client,containerPort=8000" \
          --region ${{ env.AWS_REGION }}

    - name: Update ECS service
      if: steps.check-service.outputs.service-exists == 'true'
      run: |
        aws ecs update-service \
          --cluster echo-mcp-client-cluster \
          --service echo-mcp-client-service \
          --task-definition ${{ env.TASK_DEF_ARN }} \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}

    - name: Wait for service stability
      run: |
        aws ecs wait services-stable \
          --cluster echo-mcp-client-cluster \
          --services echo-mcp-client-service \
          --region ${{ env.AWS_REGION }}

    - name: Verify deployment
      run: |
        # Check service health
        SERVICE_STATUS=$(aws ecs describe-services \
          --cluster echo-mcp-client-cluster \
          --services echo-mcp-client-service \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0].status' \
          --output text)

        if [ "$SERVICE_STATUS" != "ACTIVE" ]; then
          echo "‚ùå Service deployment failed"
          exit 1
        fi

        # Get running tasks
        RUNNING_TASKS=$(aws ecs describe-services \
          --cluster echo-mcp-client-cluster \
          --services echo-mcp-client-service \
          --region ${{ env.AWS_REGION }} \
          --query 'services[0].runningCount' \
          --output text)

        if [ "$RUNNING_TASKS" -eq 0 ]; then
          echo "‚ùå No running tasks found"
          exit 1
        fi

        echo "‚úÖ Service deployed successfully with $RUNNING_TASKS running tasks"

    - name: Get service endpoint
      run: |
        ALB_DNS=$(aws cloudformation describe-stacks \
          --stack-name echo-mcp-client-infrastructure \
          --region ${{ env.AWS_REGION }} \
          --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
          --output text)

        echo "üåê Application URL: https://echo-mcp-client.qkiu.tech"
        echo "üîç Health check: https://echo-mcp-client.qkiu.tech/health"
        echo "üîå WebSocket endpoint: wss://echo-mcp-client.qkiu.tech/ws/agent/{user_id}"
        echo "üìä ALB DNS: $ALB_DNS"

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "üéâ Deployment completed successfully!"
        else
          echo "‚ùå Deployment failed!"
          # You could add notification logic here (Slack, Teams, etc.)
        fi
